# 2. Layered Architecture & Implementation Strategy

* Статус: Прийнято
* Дата: 2025-11-28

## Контекст
Методичні рекомендації пропонують структуру `api` -> `service` -> `domain`. Проте, на етапі MVP (Minimum Viable Product) більшість операцій системи зводяться до стандартних дій створення/читання/оновлення (CRUD) без складної бізнес-логіки.

## Рішення
Ми вирішили адаптувати класичну тришарову архітектуру під потреби поточного етапу проєкту, керуючись принципами **KISS** та **YAGNI**.

1. **API Layer (`backend/routers/`)**:
   * Відповідає за прийом HTTP запитів, валідацію вхідних даних (Pydantic schemas) та повернення відповідей.
   
2. **Data Access Layer (`backend/crud/`)**:
   * Виконує роль шару `Service` на даному етапі.
   * Містить логіку взаємодії з базою даних.
   * Включає базові перевірки перед записом у БД.
   
3. **Domain Layer (`backend/domain/`)**:
   * Містить чисті сутності (Entities) та бізнес-правила.
   * **Примітка до реалізації:** На поточному етапі (MVP) ми використовуємо спрощений потік даних: `API DTO` -> `ORM Model` (без проміжного мапінгу в Domain Entity). Це зроблено свідомо для зменшення бойлерплейту (зайвого коду).
   * Класи в `backend/domain/` слугують **прототипами** для складної логіки, яка буде імплементована пізніше (згідно з вимогами Практичної 3).

## Обґрунтування відхилення (Mapping)
Ми свідомо не створюємо окремий шар `backend/service/`, який би просто дублював виклики до `backend/crud/` (так званий *Pass-through Service* анти-патерн). 

Замість цього, **папка `crud` виконує функції сервісного шару**.
Якщо бізнес-логіка ускладниться в майбутньому (наприклад, з'являться складні транзакції або інтеграції), ми виділимо окремий шар `service` шляхом рефакторингу.

## Правила залежностей
* `API` залежить від `CRUD`.
* `CRUD` залежить від `Domain` та моделей БД.
* `Domain` ні від чого не залежить.